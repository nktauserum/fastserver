#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/epoll.h>
#include <fcntl.h>
#include <errno.h>

#include "request.h"

#define PORT 5000
#define QUEUE_SIZE 2048
#define WORKERS_COUNT 16

struct {
    int port;
    int server_fd;
    struct sockaddr_in server_addr;
} server;

typedef struct {
    int* queue[QUEUE_SIZE]; 
    int head, tail, size;

    pthread_mutex_t mu;
    pthread_cond_t cond;
} incoming_connections_buf;

void* worker(void* arg) {
    incoming_connections_buf* buf = arg;

    while (1) {
        pthread_mutex_lock(&buf->mu);
        while (buf->size == 0) pthread_cond_wait(&buf->cond, &buf->mu);

        int* clientfd = buf->queue[buf->tail];
        buf->tail = (buf->tail + 1) % QUEUE_SIZE;
        buf->size--;
        pthread_mutex_unlock(&buf->mu);

        handle_request(clientfd);

        close(*clientfd);
        free(clientfd);
    }
}

int main(void) {
   if ((server.server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("ERROR: socket failed\n");
        return 1;
    }
    
    int opt = 1;
    if (setsockopt(server.server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        perror("ERROR: setsockopt failed\n");
        close(server.server_fd);
        return 1;
    }

    server.server_addr.sin_family = AF_INET;
    server.server_addr.sin_addr.s_addr = INADDR_ANY;
    server.server_addr.sin_port = htons(PORT);
    
    if (bind(
        server.server_fd,
        (struct sockaddr *)&server.server_addr,
        sizeof(server.server_addr)) < 0) {
        perror("ERROR: bind failed\n");
        close(server.server_fd);
        return 1;
    }

    if (listen(server.server_fd, SOMAXCONN) < 0) {
        perror("ERROR: listen failed\n");
        close(server.server_fd);
        return 1;
    }
    
    if (fcntl(server.server_fd, F_SETFL, O_NONBLOCK) < 0) {
        perror("ERROR: fcntl failed\n");
        close(server.server_fd);
        return 1;
    }

    printf("INFO: server successfully started on port %d\n", PORT);

    // initializing the buffer
    incoming_connections_buf buf;
    pthread_mutex_init(&buf.mu, NULL);
    pthread_cond_init(&buf.cond, NULL);
    buf.head = buf.tail = buf.size = 0;

    pthread_t workers[WORKERS_COUNT];
    for (int i = 0; i < WORKERS_COUNT; ++i)
        pthread_create(&workers[i], NULL, worker, &buf);

    int epfd = epoll_create1(0);
    struct epoll_event ev = {.events = EPOLLIN, .data.fd = server.server_fd};
    epoll_ctl(epfd, EPOLL_CTL_ADD, server.server_fd, &ev);    

    while (1) {
        struct epoll_event events[64];
        int n = epoll_wait(epfd, events, 64, -1);

        for (int i = 0; i < n; ++i) {
            if (events[i].data.fd == server.server_fd) {
                while (1) {
                    int *clientfd = (int*)malloc(sizeof(int));
                    if (!clientfd) break;

                    if ((*clientfd = accept(server.server_fd, NULL, NULL)) < 0 ) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) break;
                        perror("ERROR: accept failed\n");
                        free(clientfd);
                        break;
                    }

                    pthread_mutex_lock(&buf.mu);

                    if (buf.size < QUEUE_SIZE) {
                        buf.queue[buf.head] = clientfd;
                        buf.head = (buf.head + 1) % QUEUE_SIZE;
                        buf.size++;
                        pthread_cond_signal(&buf.cond);
                    } else {
                        close(*clientfd);
                        free(clientfd);
                    }

                    pthread_mutex_unlock(&buf.mu);
                }
            }
        }
    }
    
    return 0;
}